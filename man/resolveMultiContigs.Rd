% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/VDJ.utils.R
\name{resolveMultiContigs}
\alias{resolveMultiContigs}
\title{Resolve VDJ chains multiplets, eventually using prior clustering knowledge}
\usage{
resolveMultiContigs(
  db,
  split.by = NULL,
  chain = c("IGH", "IGL", "IGK"),
  assay = "assay",
  resolve_multi_CDR3 = TRUE,
  use_clone = FALSE,
  analysis_name = "All_sequences",
  output = TRUE,
  output_folder = "VDJ_QC/",
  second_columns = c("sequence_id", "locus", "umi_count", "consensus_count", "sequence",
    "v_call", "d_call", "j_call", "c_call", "junction", "junction_aa", "productive",
    "complete_vdj"),
  cell_id = "cell_id",
  sequence_id = "sequence_id",
  locus = "locus",
  consensus_count = "consensus_count",
  umi_count = "umi_count",
  v_call = "v_call",
  j_call = "j_call",
  c_call = "c_call",
  junction = "junction",
  junction_aa = "junction_aa",
  dominant = "dominant",
  productive = "productive",
  complete_vdj = "complete_vdj",
  clone_id = "clone_id",
  nproc = 1
)
}
\arguments{
\item{db}{a dataframe containing heavy and light chain sequences, cell_ids, umi_counts, consensus counts (reads), productive and complete_vdj (or frw/cdr infos) columns.}

\item{split.by}{name of the column in the dataframe to use to split the dataset prior to filtering heavy chain}

\item{chain}{chain(s) to filter, should be one of "IGH", "IGL", "IGK" or c("IGL", "IGK"), will return one chain per cell for the selected chain(s).}

\item{resolve_multi_CDR3}{whether to pool contigs with similar v_call, j_call and junction_aa in a given cell (cell_id)}

\item{use_clone}{whether to use prior clustering knowledge, a clone_id column should be present.}

\item{analysis_name}{name to use for outputs prefixes.}

\item{output}{whether to output graphs with umi_counts for dominant versus second IGH VDJ contig and the recap excel workbook. If set to FALSE, only the corrected database is returned.}

\item{output_folder}{name of the folder in which graph for light chain clustering will be saved.}

\item{second_columns}{which columns info to keep for secondary contigs of interest}

\item{cell_id}{name of the column containing cell identifier.}

\item{sequence_id}{name of the column containing sequence identifier.}

\item{locus}{name of the column containing locus informations}

\item{consensus_count}{name of the column containing the number of reads for this contig (usually called consensus_count)}

\item{umi_count}{name of the column containing the number of unique molecules (UMI) for this contig. Previously called "duplicate_count" in an earlier AIRR standard}

\item{v_call}{name of the column containing V-segment allele assignments. All
entries in this column should be identical to the gene level.}

\item{j_call}{name of the column containing J-segment allele assignments. All
entries in this column should be identical to the gene level.}

\item{c_call}{name of the column containing c_call informations}

\item{junction}{name of the column containing junction informations (nucleotide format)}

\item{junction_aa}{name of the column containing identified junction in amino-acid format.}

\item{dominant}{name of the column containing BD SevenBridges contig dominance informations}

\item{productive}{name of the column containing the info whether a given sequence is productive.}

\item{complete_vdj}{name of the column containing contig completness informations}

\item{clone_id}{name of the column containing cell identifier.#'}

\item{nproc}{number of processor(s) to use (passed to scoper::hierarchicalClones()).}
}
\value{
a data frame containing the filtered chain for all cells as well as all initial columns and rows not related to that chain (or pair of chains) in the provided dataframe.
the following columns are added: unfiltered_bin, filtered_bin (outputs of binContigs pre and post filtering), pct_of_reads (% of total read in a given cell for each contig).
If use_clone = TRUE and expanded heavy chain clones are found, will run scoper::hierarchicalClones() and return a light_group column corresponding to light chain clustering as well as a graph for minimum distance between and maximal distance inside light clones.
All columns listed in the second_columns argument are also added for cells with two or more dominant light chain detected with a "second_" prefix.
}
\description{
\code{resolveMultiContigs} resolve cases of multiple heavy or light chains within a cell
}
\details{
it is recommended to perform such filtering at the level of each independent sample (split.by argument) as it will attempt to infer multimodal bins based on sample-intrinsic counts distribution.
requires the following columns in the provided database: "cell_id", "locus", "umi_count", "productive", "junction", "junction_aa", "consensus_count", "sequence", "v_call", "j_call", "c_call".
1. will first pool contigs with similar CDR3, remove non-productive (if at least one productive if present in the cell) and filter for contigs representing at least 20% of all reads in a given cell;
2. if use_clone = TRUE, will first cluster IGK/IGL contigs from expanded clones using scoper::HierarchicalClones() and a threshold of 0.1 and cases of cells with multiple light chain calls will then be resolved within each heavy chain-based clones (provided clone_id), using the following rules:
   2.1 clonally related light chain contigs within one cell are pulled and the best quality one (highest umi_count and completeness) is kept;
   2.2 clonally related light chain contigs between cells in a heavy chain-based clone are selected in priority for all of these cells;
   2.3 if no clonally related light chain is found, noncontig is selected at this step.
3. to break remaining ties, the contigs are then sorted in order of: productivity, umi_count bin, full length, highest molecule count, highest read count.
dependencies: dplyr, ggplot2, openxlsx, alakazam, dowser

[note] technically, dowser::resolveLightChains can deal with multiple light chains but choice of dominant light chain doesn't take into account umi_counts (selection seem purely based on alphabetical ordering of light chains...).
we use her a similar approach to preprocess the best light chain(s) for a given cell_id. The preprocess db can then be runned through dowser::resolveLightChains for splitting of heavy chain only-based clones using light chain info.

clonal grouping should be done beforehand (scoper::HierarchicalClones()or SpectralClones()), without splitting by light chain (only_heavy = TRUE and split_light = FALSE).
scoper::HierarchicalClones() also provides light chain selection but unlike dowser::resolveLightChains(), it doesn't work with cells missing a light chain.
}
